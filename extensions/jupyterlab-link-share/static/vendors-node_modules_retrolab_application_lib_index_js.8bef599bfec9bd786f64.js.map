{"version":3,"file":"vendors-node_modules_retrolab_application_lib_index_js.8bef599bfec9bd786f64.js","mappings":";;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACoE;AACd;AACtD;AACA;AACA;AACO,4BAA4B,oDAAK;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,8DAAe;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,yCAAyC;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,YAAY;AAC5B;AACA,oDAAoD,WAAW;AAC/D;AACA;AACA;AACA,gBAAgB,4BAA4B;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,UAAU,GAAG,WAAW;AAC5D;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,gCAAgC,UAAU,GAAG,WAAW;AACxD;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,iCAAiC,kEAAmB;AACpD;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,8DAA8D,aAAa;AAC3E,8BAA8B,aAAa;AAC3C;AACA;AACA;AACA;AACA,6CAA6C,KAAK,qBAAqB,KAAK;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,8DAA8D,aAAa;AAC3E,8BAA8B,aAAa;AAC3C;AACA;AACA;AACA;AACA,6CAA6C,KAAK,qBAAqB,KAAK;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,gEAAgB;AAC/C;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE,KAAK;AACxE;AACA;AACA;AACA,oBAAoB,wBAAwB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,+BAA+B;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,qCAAqC;AAChE;AACA;AACA;AACA,CAAC,0BAA0B;AAC3B;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACheA;AACA;AACqD;AACS;AACD;AACP;AACF;AACV;AACY;AACH;AACnD;AACA;AACA;AACO,iCAAiC,oDAAK;AAC7C;AACA;AACA;AACO;AACP;AACA;AACA,wBAAwB,+DAAa,GAAG,WAAW;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA,mBAAmB,4DAAe;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,uCAAuC,oBAAoB,GAAG,wCAAwC;AACtG,iBAAiB;AACjB;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,mBAAmB,uEAAmB,EAAE,gEAAW;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,SAAS,MAAM,sEAAe,GAAG,eAAe,GAAG;AAC9G;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,oCAAoC,wEAAmB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,gEAAgB;AACtD;AACA;AACA,KAAK;AACL,CAAC,0BAA0B;AAC3B;;;;;;;;;;;;;;;;;;;;;AC7IA;AACA;AAC0C;AACc;AACb;AAC3C;AACA;AACA;AACA;AACO,uBAAuB,oDAAK;AACnC;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,qDAAM;AACrC,gCAAgC,qDAAM;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,kEAAkB;AACrC;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,kEAAkB;AACrC;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;;;;;;;;;;;;;;;;;;;;ACtF6D;AAClB;;AAE3C;AACA;AACA,gEAAgE;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,gBAAgB,sCAAsC,kBAAkB;AACnF,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA,iDAAiD,OAAO;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC,iEAAiE,wBAAwB;AACzH;AACA,KAAK;AACL;AACA;AACA;AACA,cAAc,6BAA6B,0BAA0B,cAAc,qBAAqB;AACxG,iBAAiB,oDAAoD,qEAAqE,cAAc;AACxJ,uBAAuB,sBAAsB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC,mCAAmC,SAAS;AAC5C,mCAAmC,WAAW,UAAU;AACxD,0CAA0C,cAAc;AACxD;AACA,8GAA8G,OAAO;AACrH,iFAAiF,iBAAiB;AAClG,yDAAyD,gBAAgB,QAAQ;AACjF,+CAA+C,gBAAgB,gBAAgB;AAC/E;AACA,kCAAkC;AAClC;AACA;AACA,UAAU,YAAY,aAAa,SAAS,UAAU;AACtD,oCAAoC,SAAS;AAC7C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,qDAAM;AACnC,yBAAyB,8DAAe;AACxC,2BAA2B,qDAAM;AACjC;AACA;AACA;AACA,0CAA0C,4BAA4B,iCAAiC;AACvG;AACA;AACA;AACA;AACA,sDAAsD,4CAA4C,UAAU;AAC5G;AACA;AACA,gCAAgC,4BAA4B;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,mCAAmC,gEAAiB,gCAAgC;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,6BAA6B,iCAAiC;AACxG,gDAAgD,mBAAmB;AACnE;AACA;AACA,QAAQ,+DAAgB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,gBAAgB;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,8DAAe;AACvD,2CAA2C,qGAAqG;AAChJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,oBAAoB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0BAA0B;;AAE3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,sDAAsD;AACzF;AACA;AACA;AACA;AACA,aAAa,IAAI,IAAI;AACrB,yBAAyB,uDAAuD;AAChF;AACA,SAAS;AACT,2BAA2B,8DAAe;AAC1C;AACA;AACA;AACA,oCAAoC,8DAAe;AACnD;AACA;AACA;AACA;AACA,oCAAoC,8DAAe;AACnD,qDAAqD,mBAAmB;AACxE;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,wCAAwC;AAC1E;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,4CAA4C;AAClF;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,CAAC,8BAA8B;;AAEoB;AACnD;;;;;;;;;;;;;;;;;;;;;;;ACpoBA;AACA;AAC0D;AAC0B;AACrB;AACZ;AACP;AACP;AACrC;AACA;AACA;AACO,uBAAuB,oEAAe;AAC7C;AACA;AACA;AACA;AACA;AACA,4BAA4B,WAAW,8CAAU,IAAI;AACrD;AACA,4CAA4C,cAAc,iEAAiE,8CAAU,IAAI;AACzI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,yEAAS;AACnC;AACA;AACA;AACA,6BAA6B,uEAAoB;AACjD,8BAA8B,sDAAS;AACvC;AACA,SAAS;AACT;AACA,iCAAiC,kGAAuB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,uEAAoB;AAC1C,0BAA0B,uEAAoB;AAC9C,qBAAqB,uEAAoB;AACzC,wBAAwB,uEAAoB;AAC5C,0BAA0B,uEAAoB;AAC9C,wBAAwB,uEAAoB;AAC5C,qBAAqB,uEAAoB;AACzC,8BAA8B,uEAAoB;AAClD,yBAAyB,uEAAoB;AAC7C,2BAA2B,uEAAoB;AAC/C,yBAAyB,uEAAoB;AAC7C,+BAA+B,uEAAoB;AACnD,aAAa;AACb;AACA,6BAA6B,uEAAoB;AACjD,yBAAyB,uEAAoB;AAC7C,wBAAwB,uEAAoB;AAC5C,2BAA2B,uEAAoB;AAC/C,wBAAwB,uEAAoB;AAC5C,8BAA8B,uEAAoB;AAClD,4BAA4B,uEAAoB;AAChD,4BAA4B,uEAAoB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0BAA0B;;;;;;;;;;;;;;;;;;;AC5I3B;AACA;AACsB;AACE;;;;;;;;;;;;;;;;;;;;;;;;;;ACHxB;AACA;AACyD;AACf;AACM;AACL;AACgB;AAC3D;AACA;AACA;AACO,wBAAwB,oDAAK;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACO,yBAAyB,mDAAM;AACtC;AACA;AACA,mCAAmC,qDAAM;AACzC;AACA,+BAA+B,sDAAS;AACxC;AACA;AACA,yBAAyB,kDAAK;AAC9B;AACA;AACA;AACA;AACA,mDAAmD,kDAAK;AACxD;AACA;AACA,qDAAqD,kDAAK;AAC1D;AACA;AACA,QAAQ,iEAAoB;AAC5B,QAAQ,iEAAoB;AAC5B,QAAQ,iEAAoB;AAC5B,2BAA2B,mDAAM;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,uDAAI;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,uDAAI;AAC3B;AACA,uBAAuB,uDAAI;AAC3B;AACA,uBAAuB,uDAAI;AAC3B;AACA,iDAAiD,KAAK;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,cAAc;AAC7D;AACA;AACA;AACA;AACA;AACA,4BAA4B,wEAAyB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,kDAAK;AACnC,YAAY,6EAA8B;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B,0BAA0B,kEAAmB;AAC7C,YAAY,8DAAe;AAC3B;AACA;AACA;AACA;AACA,CAAC,0BAA0B","sources":["webpack://jupyterlab-link-share/./node_modules/@jupyterlab/application/lib/layoutrestorer.js","webpack://jupyterlab-link-share/./node_modules/@jupyterlab/application/lib/mimerenderers.js","webpack://jupyterlab-link-share/./node_modules/@jupyterlab/application/lib/status.js","webpack://jupyterlab-link-share/./node_modules/@lumino/polling/dist/index.es6.js","webpack://jupyterlab-link-share/./node_modules/@retrolab/application/lib/app.js","webpack://jupyterlab-link-share/./node_modules/@retrolab/application/lib/index.js","webpack://jupyterlab-link-share/./node_modules/@retrolab/application/lib/shell.js"],"sourcesContent":["/* -----------------------------------------------------------------------------\n| Copyright (c) Jupyter Development Team.\n| Distributed under the terms of the Modified BSD License.\n|----------------------------------------------------------------------------*/\nimport { JSONExt, PromiseDelegate, Token } from '@lumino/coreutils';\nimport { AttachedProperty } from '@lumino/properties';\n/**\n * The layout restorer token.\n */\nexport const ILayoutRestorer = new Token('@jupyterlab/application:ILayoutRestorer');\n/**\n * The data connector key for restorer data.\n */\nconst KEY = 'layout-restorer:data';\n/**\n * The default implementation of a layout restorer.\n *\n * #### Notes\n * The lifecycle for state restoration is subtle. The sequence of events is:\n *\n * 1. The layout restorer plugin is instantiated and makes a `fetch` call to\n *    the data connector that stores the layout restoration data. The `fetch`\n *    call returns a promise that resolves in step 6, below.\n *\n * 2. Other plugins that care about state restoration require the layout\n *    restorer as a dependency.\n *\n * 3. As each load-time plugin initializes (which happens before the front-end\n *    application has `started`), it instructs the layout restorer whether\n *    the restorer ought to `restore` its widgets by passing in its widget\n *    tracker.\n *    Alternatively, a plugin that does not require its own widget tracker\n *    (because perhaps it only creates a single widget, like a command palette),\n *    can simply `add` its widget along with a persistent unique name to the\n *    layout restorer so that its layout state can be restored when the lab\n *    application restores.\n *\n * 4. After all the load-time plugins have finished initializing, the front-end\n *    application `started` promise will resolve. This is the `first`\n *    promise that the layout restorer waits for. By this point, all of the\n *    plugins that care about restoration will have instructed the layout\n *    restorer to `restore` their widget trackers.\n *\n * 5. The layout restorer will then instruct each plugin's widget tracker\n *    to restore its state and reinstantiate whichever widgets it wants. The\n *    tracker returns a promise to the layout restorer that resolves when it\n *    has completed restoring the tracked widgets it cares about.\n *\n * 6. As each widget tracker finishes restoring the widget instances it cares\n *    about, it resolves the promise that was returned to the layout restorer\n *    (in step 5). After all of the promises that the restorer is awaiting have\n *    settled, the restorer then resolves the outstanding `fetch` promise\n *    (from step 1) and hands off a layout state object to the application\n *    shell's `restoreLayout` method for restoration.\n *\n * 7. Once the application shell has finished restoring the layout, the\n *    JupyterLab application's `restored` promise is resolved.\n *\n * Of particular note are steps 5 and 6: since data restoration of plugins\n * is accomplished by executing commands, the command that is used to restore\n * the data of each plugin must return a promise that only resolves when the\n * widget has been created and added to the plugin's widget tracker.\n */\nexport class LayoutRestorer {\n    /**\n     * Create a layout restorer.\n     */\n    constructor(options) {\n        this._firstDone = false;\n        this._promisesDone = false;\n        this._promises = [];\n        this._restored = new PromiseDelegate();\n        this._trackers = new Set();\n        this._widgets = new Map();\n        this._connector = options.connector;\n        this._first = options.first;\n        this._registry = options.registry;\n        void this._first\n            .then(() => {\n            this._firstDone = true;\n        })\n            .then(() => Promise.all(this._promises))\n            .then(() => {\n            this._promisesDone = true;\n            // Release the tracker set.\n            this._trackers.clear();\n        })\n            .then(() => {\n            this._restored.resolve(void 0);\n        });\n    }\n    /**\n     * A promise resolved when the layout restorer is ready to receive signals.\n     */\n    get restored() {\n        return this._restored.promise;\n    }\n    /**\n     * Add a widget to be tracked by the layout restorer.\n     */\n    add(widget, name) {\n        Private.nameProperty.set(widget, name);\n        this._widgets.set(name, widget);\n        widget.disposed.connect(this._onWidgetDisposed, this);\n    }\n    /**\n     * Fetch the layout state for the application.\n     *\n     * #### Notes\n     * Fetching the layout relies on all widget restoration to be complete, so\n     * calls to `fetch` are guaranteed to return after restoration is complete.\n     */\n    async fetch() {\n        const blank = {\n            fresh: true,\n            mainArea: null,\n            downArea: null,\n            leftArea: null,\n            rightArea: null,\n            relativeSizes: null\n        };\n        const layout = this._connector.fetch(KEY);\n        try {\n            const [data] = await Promise.all([layout, this.restored]);\n            if (!data) {\n                return blank;\n            }\n            const { main, down, left, right, relativeSizes } = data;\n            // If any data exists, then this is not a fresh session.\n            const fresh = false;\n            // Rehydrate main area.\n            const mainArea = this._rehydrateMainArea(main);\n            // Rehydrate down area.\n            const downArea = this._rehydrateDownArea(down);\n            // Rehydrate left area.\n            const leftArea = this._rehydrateSideArea(left);\n            // Rehydrate right area.\n            const rightArea = this._rehydrateSideArea(right);\n            return {\n                fresh,\n                mainArea,\n                downArea,\n                leftArea,\n                rightArea,\n                relativeSizes: relativeSizes || null\n            };\n        }\n        catch (error) {\n            return blank;\n        }\n    }\n    /**\n     * Restore the widgets of a particular widget tracker.\n     *\n     * @param tracker - The widget tracker whose widgets will be restored.\n     *\n     * @param options - The restoration options.\n     */\n    restore(tracker, options) {\n        const warning = 'restore() can only be called before `first` has resolved.';\n        if (this._firstDone) {\n            console.warn(warning);\n            return Promise.reject(warning);\n        }\n        const { namespace } = tracker;\n        if (this._trackers.has(namespace)) {\n            const warning = `A tracker namespaced ${namespace} was already restored.`;\n            console.warn(warning);\n            return Promise.reject(warning);\n        }\n        const { args, command, name, when } = options;\n        // Add the tracker to the private trackers collection.\n        this._trackers.add(namespace);\n        // Whenever a new widget is added to the tracker, record its name.\n        tracker.widgetAdded.connect((_, widget) => {\n            const widgetName = name(widget);\n            if (widgetName) {\n                this.add(widget, `${namespace}:${widgetName}`);\n            }\n        }, this);\n        // Whenever a widget is updated, get its new name.\n        tracker.widgetUpdated.connect((_, widget) => {\n            const widgetName = name(widget);\n            if (widgetName) {\n                const name = `${namespace}:${widgetName}`;\n                Private.nameProperty.set(widget, name);\n                this._widgets.set(name, widget);\n            }\n        });\n        const first = this._first;\n        const promise = tracker\n            .restore({\n            args: args || (() => JSONExt.emptyObject),\n            command,\n            connector: this._connector,\n            name,\n            registry: this._registry,\n            when: when ? [first].concat(when) : first\n        })\n            .catch(error => {\n            console.error(error);\n        });\n        this._promises.push(promise);\n        return promise;\n    }\n    /**\n     * Save the layout state for the application.\n     */\n    save(data) {\n        // If there are promises that are unresolved, bail.\n        if (!this._promisesDone) {\n            const warning = 'save() was called prematurely.';\n            console.warn(warning);\n            return Promise.reject(warning);\n        }\n        const dehydrated = {};\n        dehydrated.main = this._dehydrateMainArea(data.mainArea);\n        dehydrated.down = this._dehydrateDownArea(data.downArea);\n        dehydrated.left = this._dehydrateSideArea(data.leftArea);\n        dehydrated.right = this._dehydrateSideArea(data.rightArea);\n        dehydrated.relativeSizes = data.relativeSizes;\n        return this._connector.save(KEY, dehydrated);\n    }\n    /**\n     * Dehydrate a main area description into a serializable object.\n     */\n    _dehydrateMainArea(area) {\n        if (!area) {\n            return null;\n        }\n        return Private.serializeMain(area);\n    }\n    /**\n     * Reydrate a serialized main area description object.\n     *\n     * #### Notes\n     * This function consumes data that can become corrupted, so it uses type\n     * coercion to guarantee the dehydrated object is safely processed.\n     */\n    _rehydrateMainArea(area) {\n        if (!area) {\n            return null;\n        }\n        return Private.deserializeMain(area, this._widgets);\n    }\n    /**\n     * Dehydrate a down area description into a serializable object.\n     */\n    _dehydrateDownArea(area) {\n        if (!area) {\n            return null;\n        }\n        const dehydrated = {\n            size: area.size\n        };\n        if (area.currentWidget) {\n            const current = Private.nameProperty.get(area.currentWidget);\n            if (current) {\n                dehydrated.current = current;\n            }\n        }\n        if (area.widgets) {\n            dehydrated.widgets = area.widgets\n                .map(widget => Private.nameProperty.get(widget))\n                .filter(name => !!name);\n        }\n        return dehydrated;\n    }\n    /**\n     * Reydrate a serialized side area description object.\n     *\n     * #### Notes\n     * This function consumes data that can become corrupted, so it uses type\n     * coercion to guarantee the dehydrated object is safely processed.\n     */\n    _rehydrateDownArea(area) {\n        var _a;\n        if (!area) {\n            return { currentWidget: null, size: 0.0, widgets: null };\n        }\n        const internal = this._widgets;\n        const currentWidget = area.current && internal.has(`${area.current}`)\n            ? internal.get(`${area.current}`)\n            : null;\n        const widgets = !Array.isArray(area.widgets)\n            ? null\n            : area.widgets\n                .map(name => internal.has(`${name}`) ? internal.get(`${name}`) : null)\n                .filter(widget => !!widget);\n        return {\n            currentWidget: currentWidget,\n            size: (_a = area.size) !== null && _a !== void 0 ? _a : 0.0,\n            widgets: widgets\n        };\n    }\n    /**\n     * Dehydrate a side area description into a serializable object.\n     */\n    _dehydrateSideArea(area) {\n        if (!area) {\n            return null;\n        }\n        const dehydrated = { collapsed: area.collapsed };\n        if (area.currentWidget) {\n            const current = Private.nameProperty.get(area.currentWidget);\n            if (current) {\n                dehydrated.current = current;\n            }\n        }\n        if (area.widgets) {\n            dehydrated.widgets = area.widgets\n                .map(widget => Private.nameProperty.get(widget))\n                .filter(name => !!name);\n        }\n        return dehydrated;\n    }\n    /**\n     * Reydrate a serialized side area description object.\n     *\n     * #### Notes\n     * This function consumes data that can become corrupted, so it uses type\n     * coercion to guarantee the dehydrated object is safely processed.\n     */\n    _rehydrateSideArea(area) {\n        var _a;\n        if (!area) {\n            return { collapsed: true, currentWidget: null, widgets: null };\n        }\n        const internal = this._widgets;\n        const collapsed = (_a = area.collapsed) !== null && _a !== void 0 ? _a : false;\n        const currentWidget = area.current && internal.has(`${area.current}`)\n            ? internal.get(`${area.current}`)\n            : null;\n        const widgets = !Array.isArray(area.widgets)\n            ? null\n            : area.widgets\n                .map(name => internal.has(`${name}`) ? internal.get(`${name}`) : null)\n                .filter(widget => !!widget);\n        return {\n            collapsed,\n            currentWidget: currentWidget,\n            widgets: widgets\n        };\n    }\n    /**\n     * Handle a widget disposal.\n     */\n    _onWidgetDisposed(widget) {\n        const name = Private.nameProperty.get(widget);\n        this._widgets.delete(name);\n    }\n}\n/*\n * A namespace for private data.\n */\nvar Private;\n(function (Private) {\n    /**\n     * An attached property for a widget's ID in the serialized restore data.\n     */\n    Private.nameProperty = new AttachedProperty({\n        name: 'name',\n        create: owner => ''\n    });\n    /**\n     * Serialize individual areas within the main area.\n     */\n    function serializeArea(area) {\n        if (!area || !area.type) {\n            return null;\n        }\n        if (area.type === 'tab-area') {\n            return {\n                type: 'tab-area',\n                currentIndex: area.currentIndex,\n                widgets: area.widgets\n                    .map(widget => Private.nameProperty.get(widget))\n                    .filter(name => !!name)\n            };\n        }\n        return {\n            type: 'split-area',\n            orientation: area.orientation,\n            sizes: area.sizes,\n            children: area.children\n                .map(serializeArea)\n                .filter(area => !!area)\n        };\n    }\n    /**\n     * Return a dehydrated, serializable version of the main dock panel.\n     */\n    function serializeMain(area) {\n        const dehydrated = {\n            dock: (area && area.dock && serializeArea(area.dock.main)) || null\n        };\n        if (area) {\n            if (area.currentWidget) {\n                const current = Private.nameProperty.get(area.currentWidget);\n                if (current) {\n                    dehydrated.current = current;\n                }\n            }\n        }\n        return dehydrated;\n    }\n    Private.serializeMain = serializeMain;\n    /**\n     * Deserialize individual areas within the main area.\n     *\n     * #### Notes\n     * Because this data comes from a potentially unreliable foreign source, it is\n     * typed as a `JSONObject`; but the actual expected type is:\n     * `ITabArea | ISplitArea`.\n     *\n     * For fault tolerance, types are manually checked in deserialization.\n     */\n    function deserializeArea(area, names) {\n        if (!area) {\n            return null;\n        }\n        // Because this data is saved to a foreign data source, its type safety is\n        // not guaranteed when it is retrieved, so exhaustive checks are necessary.\n        const type = area.type || 'unknown';\n        if (type === 'unknown' || (type !== 'tab-area' && type !== 'split-area')) {\n            console.warn(`Attempted to deserialize unknown type: ${type}`);\n            return null;\n        }\n        if (type === 'tab-area') {\n            const { currentIndex, widgets } = area;\n            const hydrated = {\n                type: 'tab-area',\n                currentIndex: currentIndex || 0,\n                widgets: (widgets &&\n                    widgets\n                        .map(widget => names.get(widget))\n                        .filter(widget => !!widget)) ||\n                    []\n            };\n            // Make sure the current index is within bounds.\n            if (hydrated.currentIndex > hydrated.widgets.length - 1) {\n                hydrated.currentIndex = 0;\n            }\n            return hydrated;\n        }\n        const { orientation, sizes, children } = area;\n        const hydrated = {\n            type: 'split-area',\n            orientation: orientation,\n            sizes: sizes || [],\n            children: (children &&\n                children\n                    .map(child => deserializeArea(child, names))\n                    .filter(widget => !!widget)) ||\n                []\n        };\n        return hydrated;\n    }\n    /**\n     * Return the hydrated version of the main dock panel, ready to restore.\n     *\n     * #### Notes\n     * Because this data comes from a potentially unreliable foreign source, it is\n     * typed as a `JSONObject`; but the actual expected type is: `IMainArea`.\n     *\n     * For fault tolerance, types are manually checked in deserialization.\n     */\n    function deserializeMain(area, names) {\n        if (!area) {\n            return null;\n        }\n        const name = area.current || null;\n        const dock = area.dock || null;\n        return {\n            currentWidget: (name && names.has(name) && names.get(name)) || null,\n            dock: dock ? { main: deserializeArea(dock, names) } : null\n        };\n    }\n    Private.deserializeMain = deserializeMain;\n})(Private || (Private = {}));\n//# sourceMappingURL=layoutrestorer.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { WidgetTracker } from '@jupyterlab/apputils';\nimport { MimeDocumentFactory } from '@jupyterlab/docregistry';\nimport { IRenderMimeRegistry } from '@jupyterlab/rendermime';\nimport { ITranslator } from '@jupyterlab/translation';\nimport { LabIcon } from '@jupyterlab/ui-components';\nimport { Token } from '@lumino/coreutils';\nimport { AttachedProperty } from '@lumino/properties';\nimport { ILayoutRestorer } from './layoutrestorer';\n/**\n * The mime document tracker token.\n */\nexport const IMimeDocumentTracker = new Token('@jupyterlab/application:IMimeDocumentTracker');\n/**\n * Create rendermime plugins for rendermime extension modules.\n */\nexport function createRendermimePlugins(extensions) {\n    const plugins = [];\n    const namespace = 'application-mimedocuments';\n    const tracker = new WidgetTracker({ namespace });\n    extensions.forEach(mod => {\n        let data = mod.default;\n        // Handle CommonJS exports.\n        if (!mod.hasOwnProperty('__esModule')) {\n            data = mod;\n        }\n        if (!Array.isArray(data)) {\n            data = [data];\n        }\n        data.forEach(item => {\n            plugins.push(createRendermimePlugin(tracker, item));\n        });\n    });\n    // Also add a meta-plugin handling state restoration\n    // and exposing the mime document widget tracker.\n    plugins.push({\n        id: '@jupyterlab/application:mimedocument',\n        optional: [ILayoutRestorer],\n        provides: IMimeDocumentTracker,\n        autoStart: true,\n        activate: (app, restorer) => {\n            if (restorer) {\n                void restorer.restore(tracker, {\n                    command: 'docmanager:open',\n                    args: widget => ({\n                        path: widget.context.path,\n                        factory: Private.factoryNameProperty.get(widget)\n                    }),\n                    name: widget => `${widget.context.path}:${Private.factoryNameProperty.get(widget)}`\n                });\n            }\n            return tracker;\n        }\n    });\n    return plugins;\n}\n/**\n * Create rendermime plugins for rendermime extension modules.\n */\nexport function createRendermimePlugin(tracker, item) {\n    return {\n        id: item.id,\n        requires: [IRenderMimeRegistry, ITranslator],\n        autoStart: true,\n        activate: (app, rendermime, translator) => {\n            // Add the mime renderer.\n            if (item.rank !== undefined) {\n                rendermime.addFactory(item.rendererFactory, item.rank);\n            }\n            else {\n                rendermime.addFactory(item.rendererFactory);\n            }\n            // Handle the widget factory.\n            if (!item.documentWidgetFactoryOptions) {\n                return;\n            }\n            const registry = app.docRegistry;\n            let options = [];\n            if (Array.isArray(item.documentWidgetFactoryOptions)) {\n                options = item.documentWidgetFactoryOptions;\n            }\n            else {\n                options = [\n                    item.documentWidgetFactoryOptions\n                ];\n            }\n            if (item.fileTypes) {\n                item.fileTypes.forEach(ft => {\n                    if (ft.icon) {\n                        // upconvert the contents of the icon field to a proper LabIcon\n                        ft = Object.assign(Object.assign({}, ft), { icon: LabIcon.resolve({ icon: ft.icon }) });\n                    }\n                    app.docRegistry.addFileType(ft);\n                });\n            }\n            options.forEach(option => {\n                const toolbarFactory = option.toolbarFactory\n                    ? (w) => option.toolbarFactory(w.content.renderer)\n                    : undefined;\n                const factory = new MimeDocumentFactory({\n                    renderTimeout: item.renderTimeout,\n                    dataType: item.dataType,\n                    rendermime,\n                    modelName: option.modelName,\n                    name: option.name,\n                    primaryFileType: registry.getFileType(option.primaryFileType),\n                    fileTypes: option.fileTypes,\n                    defaultFor: option.defaultFor,\n                    defaultRendered: option.defaultRendered,\n                    toolbarFactory,\n                    translator,\n                    factory: item.rendererFactory\n                });\n                registry.addWidgetFactory(factory);\n                factory.widgetCreated.connect((sender, widget) => {\n                    Private.factoryNameProperty.set(widget, factory.name);\n                    // Notify the widget tracker if restore data needs to update.\n                    widget.context.pathChanged.connect(() => {\n                        void tracker.save(widget);\n                    });\n                    void tracker.add(widget);\n                });\n            });\n        }\n    };\n}\n/**\n * Private namespace for the module.\n */\nvar Private;\n(function (Private) {\n    /**\n     * An attached property for keeping the factory name\n     * that was used to create a mimedocument.\n     */\n    Private.factoryNameProperty = new AttachedProperty({\n        name: 'factoryName',\n        create: () => undefined\n    });\n})(Private || (Private = {}));\n//# sourceMappingURL=mimerenderers.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { Token } from '@lumino/coreutils';\nimport { DisposableDelegate } from '@lumino/disposable';\nimport { Signal } from '@lumino/signaling';\n/* tslint:disable */\n/**\n * The application status token.\n */\nexport const ILabStatus = new Token('@jupyterlab/application:ILabStatus');\n/**\n * The application status signals and flags class.\n */\nexport class LabStatus {\n    /**\n     * Construct a new  status object.\n     */\n    constructor(app) {\n        this._busyCount = 0;\n        this._dirtyCount = 0;\n        this._busySignal = new Signal(app);\n        this._dirtySignal = new Signal(app);\n    }\n    /**\n     * Returns a signal for when application changes its busy status.\n     */\n    get busySignal() {\n        return this._busySignal;\n    }\n    /**\n     * Returns a signal for when application changes its dirty status.\n     */\n    get dirtySignal() {\n        return this._dirtySignal;\n    }\n    /**\n     * Whether the application is busy.\n     */\n    get isBusy() {\n        return this._busyCount > 0;\n    }\n    /**\n     * Whether the application is dirty.\n     */\n    get isDirty() {\n        return this._dirtyCount > 0;\n    }\n    /**\n     * Set the application state to dirty.\n     *\n     * @returns A disposable used to clear the dirty state for the caller.\n     */\n    setDirty() {\n        const oldDirty = this.isDirty;\n        this._dirtyCount++;\n        if (this.isDirty !== oldDirty) {\n            this._dirtySignal.emit(this.isDirty);\n        }\n        return new DisposableDelegate(() => {\n            const oldDirty = this.isDirty;\n            this._dirtyCount = Math.max(0, this._dirtyCount - 1);\n            if (this.isDirty !== oldDirty) {\n                this._dirtySignal.emit(this.isDirty);\n            }\n        });\n    }\n    /**\n     * Set the application state to busy.\n     *\n     * @returns A disposable used to clear the busy state for the caller.\n     */\n    setBusy() {\n        const oldBusy = this.isBusy;\n        this._busyCount++;\n        if (this.isBusy !== oldBusy) {\n            this._busySignal.emit(this.isBusy);\n        }\n        return new DisposableDelegate(() => {\n            const oldBusy = this.isBusy;\n            this._busyCount--;\n            if (this.isBusy !== oldBusy) {\n                this._busySignal.emit(this.isBusy);\n            }\n        });\n    }\n}\n//# sourceMappingURL=status.js.map","import { JSONExt, PromiseDelegate } from '@lumino/coreutils';\nimport { Signal } from '@lumino/signaling';\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nfunction __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nvar __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    };\r\n    return __assign.apply(this, arguments);\r\n};\r\n\r\nfunction __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nfunction __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\n\n// Copyright (c) Jupyter Development Team.\n/**\n * A function to defer an action immediately.\n */\nvar defer = typeof requestAnimationFrame === 'function'\n    ? requestAnimationFrame\n    : setImmediate;\n/**\n * A function to cancel a deferred action.\n */\nvar cancel = typeof cancelAnimationFrame === 'function'\n    ? cancelAnimationFrame\n    : clearImmediate;\n/**\n * A class that wraps an asynchronous function to poll at a regular interval\n * with exponential increases to the interval length if the poll fails.\n *\n * @typeparam T - The resolved type of the factory's promises.\n * Defaults to `any`.\n *\n * @typeparam U - The rejected type of the factory's promises.\n * Defaults to `any`.\n *\n * @typeparam V - An optional type to extend the phases supported by a poll.\n * Defaults to `standby`, which already exists in the `Phase` type.\n */\nvar Poll = /** @class */ (function () {\n    /**\n     * Instantiate a new poll with exponential backoff in case of failure.\n     *\n     * @param options - The poll instantiation options.\n     */\n    function Poll(options) {\n        var _this = this;\n        this._disposed = new Signal(this);\n        this._tick = new PromiseDelegate();\n        this._ticked = new Signal(this);\n        this._timeout = -1;\n        this._factory = options.factory;\n        this._standby = options.standby || Private.DEFAULT_STANDBY;\n        this._state = __assign(__assign({}, Private.DEFAULT_STATE), { timestamp: new Date().getTime() });\n        // Normalize poll frequency `max` to be the greater of\n        // default `max`, `options.frequency.max`, or `options.frequency.interval`.\n        var frequency = options.frequency || {};\n        var max = Math.max(frequency.interval || 0, frequency.max || 0, Private.DEFAULT_FREQUENCY.max);\n        this.frequency = __assign(__assign(__assign({}, Private.DEFAULT_FREQUENCY), frequency), { max: max });\n        this.name = options.name || Private.DEFAULT_NAME;\n        if ('auto' in options ? options.auto : true) {\n            defer(function () { return void _this.start(); });\n        }\n    }\n    Object.defineProperty(Poll.prototype, \"disposed\", {\n        /**\n         * A signal emitted when the poll is disposed.\n         */\n        get: function () {\n            return this._disposed;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Poll.prototype, \"frequency\", {\n        /**\n         * The polling frequency parameters.\n         */\n        get: function () {\n            return this._frequency;\n        },\n        set: function (frequency) {\n            if (this.isDisposed || JSONExt.deepEqual(frequency, this.frequency || {})) {\n                return;\n            }\n            var backoff = frequency.backoff, interval = frequency.interval, max = frequency.max;\n            interval = Math.round(interval);\n            max = Math.round(max);\n            if (typeof backoff === 'number' && backoff < 1) {\n                throw new Error('Poll backoff growth factor must be at least 1');\n            }\n            if ((interval < 0 || interval > max) && interval !== Poll.NEVER) {\n                throw new Error('Poll interval must be between 0 and max');\n            }\n            if (max > Poll.MAX_INTERVAL && max !== Poll.NEVER) {\n                throw new Error(\"Max interval must be less than \" + Poll.MAX_INTERVAL);\n            }\n            this._frequency = { backoff: backoff, interval: interval, max: max };\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Poll.prototype, \"isDisposed\", {\n        /**\n         * Whether the poll is disposed.\n         */\n        get: function () {\n            return this.state.phase === 'disposed';\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Poll.prototype, \"standby\", {\n        /**\n         * Indicates when the poll switches to standby.\n         */\n        get: function () {\n            return this._standby;\n        },\n        set: function (standby) {\n            if (this.isDisposed || this.standby === standby) {\n                return;\n            }\n            this._standby = standby;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Poll.prototype, \"state\", {\n        /**\n         * The poll state, which is the content of the current poll tick.\n         */\n        get: function () {\n            return this._state;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Poll.prototype, \"tick\", {\n        /**\n         * A promise that resolves when the poll next ticks.\n         */\n        get: function () {\n            return this._tick.promise;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Poll.prototype, \"ticked\", {\n        /**\n         * A signal emitted when the poll ticks and fires off a new request.\n         */\n        get: function () {\n            return this._ticked;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Dispose the poll.\n     */\n    Poll.prototype.dispose = function () {\n        if (this.isDisposed) {\n            return;\n        }\n        this._state = __assign(__assign({}, Private.DISPOSED_STATE), { timestamp: new Date().getTime() });\n        this._tick.promise.catch(function (_) { return undefined; });\n        this._tick.reject(new Error(\"Poll (\" + this.name + \") is disposed.\"));\n        this._disposed.emit(undefined);\n        Signal.clearData(this);\n    };\n    /**\n     * Refreshes the poll. Schedules `refreshed` tick if necessary.\n     *\n     * @returns A promise that resolves after tick is scheduled and never rejects.\n     *\n     * #### Notes\n     * The returned promise resolves after the tick is scheduled, but before\n     * the polling action is run. To wait until after the poll action executes,\n     * await the `poll.tick` promise: `await poll.refresh(); await poll.tick;`\n     */\n    Poll.prototype.refresh = function () {\n        return this.schedule({\n            cancel: function (_a) {\n                var phase = _a.phase;\n                return phase === 'refreshed';\n            },\n            interval: Poll.IMMEDIATE,\n            phase: 'refreshed'\n        });\n    };\n    /**\n     * Schedule the next poll tick.\n     *\n     * @param next - The next poll state data to schedule. Defaults to standby.\n     *\n     * @param next.cancel - Cancels state transition if function returns `true`.\n     *\n     * @returns A promise that resolves when the next poll state is active.\n     *\n     * #### Notes\n     * This method is not meant to be invoked by user code typically. It is public\n     * to allow poll instances to be composed into classes that schedule ticks.\n     */\n    Poll.prototype.schedule = function (next) {\n        if (next === void 0) { next = {}; }\n        return __awaiter(this, void 0, void 0, function () {\n            var last, pending, scheduled, state, execute;\n            var _this = this;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        if (this.isDisposed) {\n                            return [2 /*return*/];\n                        }\n                        // Check if the phase transition should be canceled.\n                        if (next.cancel && next.cancel(this.state)) {\n                            return [2 /*return*/];\n                        }\n                        last = this.state;\n                        pending = this._tick;\n                        scheduled = new PromiseDelegate();\n                        state = __assign({ interval: this.frequency.interval, payload: null, phase: 'standby', timestamp: new Date().getTime() }, next);\n                        this._state = state;\n                        this._tick = scheduled;\n                        // Clear the schedule if possible.\n                        if (last.interval === Poll.IMMEDIATE) {\n                            cancel(this._timeout);\n                        }\n                        else {\n                            clearTimeout(this._timeout);\n                        }\n                        // Emit ticked signal, resolve pending promise, and await its settlement.\n                        this._ticked.emit(this.state);\n                        pending.resolve(this);\n                        return [4 /*yield*/, pending.promise];\n                    case 1:\n                        _a.sent();\n                        execute = function () {\n                            if (_this.isDisposed || _this.tick !== scheduled.promise) {\n                                return;\n                            }\n                            _this._execute();\n                        };\n                        this._timeout =\n                            state.interval === Poll.IMMEDIATE\n                                ? defer(execute)\n                                : state.interval === Poll.NEVER\n                                    ? -1\n                                    : setTimeout(execute, state.interval);\n                        return [2 /*return*/];\n                }\n            });\n        });\n    };\n    /**\n     * Starts the poll. Schedules `started` tick if necessary.\n     *\n     * @returns A promise that resolves after tick is scheduled and never rejects.\n     */\n    Poll.prototype.start = function () {\n        return this.schedule({\n            cancel: function (_a) {\n                var phase = _a.phase;\n                return phase !== 'constructed' && phase !== 'standby' && phase !== 'stopped';\n            },\n            interval: Poll.IMMEDIATE,\n            phase: 'started'\n        });\n    };\n    /**\n     * Stops the poll. Schedules `stopped` tick if necessary.\n     *\n     * @returns A promise that resolves after tick is scheduled and never rejects.\n     */\n    Poll.prototype.stop = function () {\n        return this.schedule({\n            cancel: function (_a) {\n                var phase = _a.phase;\n                return phase === 'stopped';\n            },\n            interval: Poll.NEVER,\n            phase: 'stopped'\n        });\n    };\n    /**\n     * Execute a new poll factory promise or stand by if necessary.\n     */\n    Poll.prototype._execute = function () {\n        var _this = this;\n        var standby = typeof this.standby === 'function' ? this.standby() : this.standby;\n        standby =\n            standby === 'never'\n                ? false\n                : standby === 'when-hidden'\n                    ? !!(typeof document !== 'undefined' && document && document.hidden)\n                    : standby;\n        // If in standby mode schedule next tick without calling the factory.\n        if (standby) {\n            void this.schedule();\n            return;\n        }\n        var pending = this.tick;\n        this._factory(this.state)\n            .then(function (resolved) {\n            if (_this.isDisposed || _this.tick !== pending) {\n                return;\n            }\n            void _this.schedule({\n                payload: resolved,\n                phase: _this.state.phase === 'rejected' ? 'reconnected' : 'resolved'\n            });\n        })\n            .catch(function (rejected) {\n            if (_this.isDisposed || _this.tick !== pending) {\n                return;\n            }\n            void _this.schedule({\n                interval: Private.sleep(_this.frequency, _this.state),\n                payload: rejected,\n                phase: 'rejected'\n            });\n        });\n    };\n    return Poll;\n}());\n/**\n * A namespace for `Poll` types, interfaces, and statics.\n */\n(function (Poll) {\n    /**\n     * An interval value that indicates the poll should tick immediately.\n     */\n    Poll.IMMEDIATE = 0;\n    /**\n     * Delays are 32-bit integers in many browsers so intervals need to be capped.\n     *\n     * #### Notes\n     * https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/setTimeout#Maximum_delay_value\n     */\n    Poll.MAX_INTERVAL = 2147483647;\n    /**\n     * An interval value that indicates the poll should never tick.\n     */\n    Poll.NEVER = Infinity;\n})(Poll || (Poll = {}));\n/**\n * A namespace for private module data.\n */\nvar Private;\n(function (Private) {\n    /**\n     * The default backoff growth rate if `backoff` is `true`.\n     */\n    Private.DEFAULT_BACKOFF = 3;\n    /**\n     * The default polling frequency.\n     */\n    Private.DEFAULT_FREQUENCY = {\n        backoff: true,\n        interval: 1000,\n        max: 30 * 1000\n    };\n    /**\n     * The default poll name.\n     */\n    Private.DEFAULT_NAME = 'unknown';\n    /**\n     * The default poll standby behavior.\n     */\n    Private.DEFAULT_STANDBY = 'when-hidden';\n    /**\n     * The first poll tick state's default values superseded in constructor.\n     */\n    Private.DEFAULT_STATE = {\n        interval: Poll.NEVER,\n        payload: null,\n        phase: 'constructed',\n        timestamp: new Date(0).getTime()\n    };\n    /**\n     * The disposed tick state values.\n     */\n    Private.DISPOSED_STATE = {\n        interval: Poll.NEVER,\n        payload: null,\n        phase: 'disposed',\n        timestamp: new Date(0).getTime()\n    };\n    /**\n     * Get a random integer between min and max, inclusive of both.\n     *\n     * #### Notes\n     * From\n     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/random#Getting_a_random_integer_between_two_values_inclusive\n     *\n     * From the MDN page: It might be tempting to use Math.round() to accomplish\n     * that, but doing so would cause your random numbers to follow a non-uniform\n     * distribution, which may not be acceptable for your needs.\n     */\n    function getRandomIntInclusive(min, max) {\n        min = Math.ceil(min);\n        max = Math.floor(max);\n        return Math.floor(Math.random() * (max - min + 1)) + min;\n    }\n    /**\n     * Returns the number of milliseconds to sleep before the next tick.\n     *\n     * @param frequency - The poll's base frequency.\n     * @param last - The poll's last tick.\n     */\n    function sleep(frequency, last) {\n        var backoff = frequency.backoff, interval = frequency.interval, max = frequency.max;\n        if (interval === Poll.NEVER) {\n            return interval;\n        }\n        var growth = backoff === true ? Private.DEFAULT_BACKOFF : backoff === false ? 1 : backoff;\n        var random = getRandomIntInclusive(interval, last.interval * growth);\n        return Math.min(max, random);\n    }\n    Private.sleep = sleep;\n})(Private || (Private = {}));\n\n// Copyright (c) Jupyter Development Team.\n/**\n * A base class to implement rate limiters with different invocation strategies.\n *\n * @typeparam T - The resolved type of the underlying function.\n *\n * @typeparam U - The rejected type of the underlying function.\n */\nvar RateLimiter = /** @class */ (function () {\n    /**\n     * Instantiate a rate limiter.\n     *\n     * @param fn - The function to rate limit.\n     *\n     * @param limit - The rate limit; defaults to 500ms.\n     */\n    function RateLimiter(fn, limit) {\n        var _this = this;\n        if (limit === void 0) { limit = 500; }\n        /**\n         * A promise that resolves on each successful invocation.\n         */\n        this.payload = null;\n        this.limit = limit;\n        this.poll = new Poll({\n            auto: false,\n            factory: function () { return __awaiter(_this, void 0, void 0, function () { return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, fn()];\n                    case 1: return [2 /*return*/, _a.sent()];\n                }\n            }); }); },\n            frequency: { backoff: false, interval: Poll.NEVER, max: Poll.NEVER },\n            standby: 'never'\n        });\n        this.payload = new PromiseDelegate();\n        this.poll.ticked.connect(function (_, state) {\n            var payload = _this.payload;\n            if (state.phase === 'resolved') {\n                _this.payload = new PromiseDelegate();\n                payload.resolve(state.payload);\n                return;\n            }\n            if (state.phase === 'rejected' || state.phase === 'stopped') {\n                _this.payload = new PromiseDelegate();\n                payload.promise.catch(function (_) { return undefined; });\n                payload.reject(state.payload);\n                return;\n            }\n        }, this);\n    }\n    Object.defineProperty(RateLimiter.prototype, \"isDisposed\", {\n        /**\n         * Whether the rate limiter is disposed.\n         */\n        get: function () {\n            return this.payload === null;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Disposes the rate limiter.\n     */\n    RateLimiter.prototype.dispose = function () {\n        if (this.isDisposed) {\n            return;\n        }\n        this.payload = null;\n        this.poll.dispose();\n    };\n    /**\n     * Stop the function if it is mid-flight.\n     */\n    RateLimiter.prototype.stop = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                return [2 /*return*/, this.poll.stop()];\n            });\n        });\n    };\n    return RateLimiter;\n}());\n/**\n * Wraps and debounces a function that can be called multiple times and only\n * executes the underlying function one `interval` after the last invocation.\n *\n * @typeparam T - The resolved type of the underlying function. Defaults to any.\n *\n * @typeparam U - The rejected type of the underlying function. Defaults to any.\n */\nvar Debouncer = /** @class */ (function (_super) {\n    __extends(Debouncer, _super);\n    function Debouncer() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * Invokes the function and only executes after rate limit has elapsed.\n     * Each invocation resets the timer.\n     */\n    Debouncer.prototype.invoke = function () {\n        void this.poll.schedule({ interval: this.limit, phase: 'invoked' });\n        return this.payload.promise;\n    };\n    return Debouncer;\n}(RateLimiter));\n/**\n * Wraps and throttles a function that can be called multiple times and only\n * executes the underlying function once per `interval`.\n *\n * @typeparam T - The resolved type of the underlying function. Defaults to any.\n *\n * @typeparam U - The rejected type of the underlying function. Defaults to any.\n */\nvar Throttler = /** @class */ (function (_super) {\n    __extends(Throttler, _super);\n    /**\n     * Instantiate a throttler.\n     *\n     * @param fn - The function being throttled.\n     *\n     * @param options - Throttling configuration or throttling limit in ms.\n     *\n     * #### Notes\n     * The `edge` defaults to `leading`; the `limit` defaults to `500`.\n     */\n    function Throttler(fn, options) {\n        var _this = _super.call(this, fn, typeof options === 'number' ? options : options && options.limit) || this;\n        var edge = 'leading';\n        if (typeof options !== 'number') {\n            options = options || {};\n            edge = 'edge' in options ? options.edge : edge;\n        }\n        _this._interval = edge === 'trailing' ? _this.limit : Poll.IMMEDIATE;\n        return _this;\n    }\n    /**\n     * Throttles function invocations if one is currently in flight.\n     */\n    Throttler.prototype.invoke = function () {\n        if (this.poll.state.phase !== 'invoked') {\n            void this.poll.schedule({ interval: this._interval, phase: 'invoked' });\n        }\n        return this.payload.promise;\n    };\n    return Throttler;\n}(RateLimiter));\n/**\n * A namespace for `Throttler` interfaces.\n */\n(function (Throttler) {\n})(Throttler || (Throttler = {}));\n\nexport { Debouncer, Poll, RateLimiter, Throttler };\n//# sourceMappingURL=index.es6.js.map\n","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { JupyterFrontEnd } from '@jupyterlab/application';\nimport { createRendermimePlugins } from '@jupyterlab/application/lib/mimerenderers';\nimport { LabStatus } from '@jupyterlab/application/lib/status';\nimport { PageConfig } from '@jupyterlab/coreutils';\nimport { Throttler } from '@lumino/polling';\nimport { RetroShell } from './shell';\n/**\n * App is the main application class. It is instantiated once and shared.\n */\nexport class RetroApp extends JupyterFrontEnd {\n    /**\n     * Construct a new RetroApp object.\n     *\n     * @param options The instantiation options for an application.\n     */\n    constructor(options = { shell: new RetroShell() }) {\n        var _a, _b;\n        super(Object.assign(Object.assign({}, options), { shell: (_a = options.shell) !== null && _a !== void 0 ? _a : new RetroShell() }));\n        /**\n         * The name of the application.\n         */\n        this.name = 'RetroLab';\n        /**\n         * A namespace/prefix plugins may use to denote their provenance.\n         */\n        this.namespace = this.name;\n        /**\n         * The application busy and dirty status signals and flags.\n         */\n        this.status = new LabStatus(this);\n        /**\n         * The version of the application.\n         */\n        this.version = (_b = PageConfig.getOption('appVersion')) !== null && _b !== void 0 ? _b : 'unknown';\n        this._formatter = new Throttler(() => {\n            Private.setFormat(this);\n        }, 250);\n        if (options.mimeExtensions) {\n            for (const plugin of createRendermimePlugins(options.mimeExtensions)) {\n                this.registerPlugin(plugin);\n            }\n        }\n        void this._formatter.invoke();\n    }\n    /**\n     * The JupyterLab application paths dictionary.\n     */\n    get paths() {\n        return {\n            urls: {\n                base: PageConfig.getOption('baseUrl'),\n                notFound: PageConfig.getOption('notFoundUrl'),\n                app: PageConfig.getOption('appUrl'),\n                static: PageConfig.getOption('staticUrl'),\n                settings: PageConfig.getOption('settingsUrl'),\n                themes: PageConfig.getOption('themesUrl'),\n                doc: PageConfig.getOption('docUrl'),\n                translations: PageConfig.getOption('translationsApiUrl'),\n                hubHost: PageConfig.getOption('hubHost') || undefined,\n                hubPrefix: PageConfig.getOption('hubPrefix') || undefined,\n                hubUser: PageConfig.getOption('hubUser') || undefined,\n                hubServerName: PageConfig.getOption('hubServerName') || undefined\n            },\n            directories: {\n                appSettings: PageConfig.getOption('appSettingsDir'),\n                schemas: PageConfig.getOption('schemasDir'),\n                static: PageConfig.getOption('staticDir'),\n                templates: PageConfig.getOption('templatesDir'),\n                themes: PageConfig.getOption('themesDir'),\n                userSettings: PageConfig.getOption('userSettingsDir'),\n                serverRoot: PageConfig.getOption('serverRoot'),\n                workspaces: PageConfig.getOption('workspacesDir')\n            }\n        };\n    }\n    /**\n     * Handle the DOM events for the application.\n     *\n     * @param event - The DOM event sent to the application.\n     */\n    handleEvent(event) {\n        super.handleEvent(event);\n        if (event.type === 'resize') {\n            void this._formatter.invoke();\n        }\n    }\n    /**\n     * Register plugins from a plugin module.\n     *\n     * @param mod - The plugin module to register.\n     */\n    registerPluginModule(mod) {\n        let data = mod.default;\n        // Handle commonjs exports.\n        if (!Object.prototype.hasOwnProperty.call(mod, '__esModule')) {\n            data = mod;\n        }\n        if (!Array.isArray(data)) {\n            data = [data];\n        }\n        data.forEach(item => {\n            try {\n                this.registerPlugin(item);\n            }\n            catch (error) {\n                console.error(error);\n            }\n        });\n    }\n    /**\n     * Register the plugins from multiple plugin modules.\n     *\n     * @param mods - The plugin modules to register.\n     */\n    registerPluginModules(mods) {\n        mods.forEach(mod => {\n            this.registerPluginModule(mod);\n        });\n    }\n}\n/**\n * A namespace for module-private functionality.\n */\nvar Private;\n(function (Private) {\n    /**\n     * Media query for mobile devices.\n     */\n    const MOBILE_QUERY = 'only screen and (max-width: 760px)';\n    /**\n     * Sets the `format` of a Jupyter front-end application.\n     *\n     * @param app The front-end application whose format is set.\n     */\n    function setFormat(app) {\n        app.format = window.matchMedia(MOBILE_QUERY).matches ? 'mobile' : 'desktop';\n    }\n    Private.setFormat = setFormat;\n})(Private || (Private = {}));\n","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nexport * from './app';\nexport * from './shell';\n","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { ArrayExt, find, iter } from '@lumino/algorithm';\nimport { Token } from '@lumino/coreutils';\nimport { MessageLoop } from '@lumino/messaging';\nimport { Signal } from '@lumino/signaling';\nimport { Panel, Widget, BoxLayout } from '@lumino/widgets';\n/**\n * The RetroLab application shell token.\n */\nexport const IRetroShell = new Token('@retrolab/application:IRetroShell');\n/**\n * The default rank for ranked panels.\n */\nconst DEFAULT_RANK = 900;\n/**\n * The application shell.\n */\nexport class RetroShell extends Widget {\n    constructor() {\n        super();\n        this._currentChanged = new Signal(this);\n        this.id = 'main';\n        const rootLayout = new BoxLayout();\n        this._topHandler = new Private.PanelHandler();\n        this._menuHandler = new Private.PanelHandler();\n        this._main = new Panel();\n        this._topHandler.panel.id = 'top-panel';\n        this._menuHandler.panel.id = 'menu-panel';\n        this._main.id = 'main-panel';\n        // create wrappers around the top and menu areas\n        const topWrapper = (this._topWrapper = new Panel());\n        topWrapper.id = 'top-panel-wrapper';\n        topWrapper.addWidget(this._topHandler.panel);\n        const menuWrapper = (this._menuWrapper = new Panel());\n        menuWrapper.id = 'menu-panel-wrapper';\n        menuWrapper.addWidget(this._menuHandler.panel);\n        BoxLayout.setStretch(topWrapper, 0);\n        BoxLayout.setStretch(menuWrapper, 0);\n        BoxLayout.setStretch(this._main, 1);\n        this._spacer = new Widget();\n        this._spacer.id = 'spacer-widget';\n        rootLayout.spacing = 0;\n        rootLayout.addWidget(topWrapper);\n        rootLayout.addWidget(menuWrapper);\n        rootLayout.addWidget(this._spacer);\n        rootLayout.addWidget(this._main);\n        this.layout = rootLayout;\n    }\n    /**\n     * A signal emitted when the current widget changes.\n     */\n    get currentChanged() {\n        return this._currentChanged;\n    }\n    /**\n     * The current widget in the shell's main area.\n     */\n    get currentWidget() {\n        var _a;\n        return (_a = this._main.widgets[0]) !== null && _a !== void 0 ? _a : null;\n    }\n    /**\n     * Get the top area wrapper panel\n     */\n    get top() {\n        return this._topWrapper;\n    }\n    /**\n     * Get the menu area wrapper panel\n     */\n    get menu() {\n        return this._menuWrapper;\n    }\n    /**\n     * Activate a widget in its area.\n     */\n    activateById(id) {\n        const widget = find(this.widgets('main'), w => w.id === id);\n        if (widget) {\n            widget.activate();\n        }\n    }\n    /**\n     * Add a widget to the application shell.\n     *\n     * @param widget - The widget being added.\n     *\n     * @param area - Optional region in the shell into which the widget should\n     * be added.\n     *\n     * @param options - Optional open options.\n     *\n     */\n    add(widget, area, options) {\n        var _a;\n        const rank = (_a = options === null || options === void 0 ? void 0 : options.rank) !== null && _a !== void 0 ? _a : DEFAULT_RANK;\n        if (area === 'top') {\n            return this._topHandler.addWidget(widget, rank);\n        }\n        if (area === 'menu') {\n            return this._menuHandler.addWidget(widget, rank);\n        }\n        if (area === 'main' || area === undefined) {\n            if (this._main.widgets.length > 0) {\n                // do not add the widget if there is already one\n                return;\n            }\n            this._main.addWidget(widget);\n            this._main.update();\n            this._currentChanged.emit(void 0);\n        }\n    }\n    /**\n     * Collapse the top area and the spacer to make the view more compact.\n     */\n    collapseTop() {\n        this._topWrapper.setHidden(true);\n        this._spacer.setHidden(true);\n    }\n    /**\n     * Expand the top area to show the header and the spacer.\n     */\n    expandTop() {\n        this._topWrapper.setHidden(false);\n        this._spacer.setHidden(false);\n    }\n    /**\n     * Return the list of widgets for the given area.\n     *\n     * @param area The area\n     */\n    widgets(area) {\n        switch (area !== null && area !== void 0 ? area : 'main') {\n            case 'top':\n                return iter(this._topHandler.panel.widgets);\n            case 'menu':\n                return iter(this._menuHandler.panel.widgets);\n            case 'main':\n                return iter(this._main.widgets);\n            default:\n                throw new Error(`Invalid area: ${area}`);\n        }\n    }\n}\n/**\n * A namespace for private module data.\n */\nvar Private;\n(function (Private) {\n    /**\n     * A less-than comparison function for side bar rank items.\n     */\n    function itemCmp(first, second) {\n        return first.rank - second.rank;\n    }\n    Private.itemCmp = itemCmp;\n    /**\n     * A class which manages a panel and sorts its widgets by rank.\n     */\n    class PanelHandler {\n        constructor() {\n            /**\n             * A message hook for child add/remove messages on the main area dock panel.\n             */\n            this._panelChildHook = (handler, msg) => {\n                switch (msg.type) {\n                    case 'child-added':\n                        {\n                            const widget = msg.child;\n                            // If we already know about this widget, we're done\n                            if (this._items.find(v => v.widget === widget)) {\n                                break;\n                            }\n                            // Otherwise, add to the end by default\n                            const rank = this._items[this._items.length - 1].rank;\n                            this._items.push({ widget, rank });\n                        }\n                        break;\n                    case 'child-removed':\n                        {\n                            const widget = msg.child;\n                            ArrayExt.removeFirstWhere(this._items, v => v.widget === widget);\n                        }\n                        break;\n                    default:\n                        break;\n                }\n                return true;\n            };\n            this._items = new Array();\n            this._panel = new Panel();\n            MessageLoop.installMessageHook(this._panel, this._panelChildHook);\n        }\n        /**\n         * Get the panel managed by the handler.\n         */\n        get panel() {\n            return this._panel;\n        }\n        /**\n         * Add a widget to the panel.\n         *\n         * If the widget is already added, it will be moved.\n         */\n        addWidget(widget, rank) {\n            widget.parent = null;\n            const item = { widget, rank };\n            const index = ArrayExt.upperBound(this._items, item, Private.itemCmp);\n            ArrayExt.insert(this._items, index, item);\n            this._panel.insertWidget(index, widget);\n        }\n    }\n    Private.PanelHandler = PanelHandler;\n})(Private || (Private = {}));\n"],"names":[],"sourceRoot":""}